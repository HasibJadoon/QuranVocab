Excellent â€” this catalog is strong, orthodox, and future-proof.
What you need now is a clean, executable parser contract that uses exactly these catalogs (no extra theory, no ambiguity).

Below is a tight, AI-passable rule set that plugs directly into what you posted.

â¸»

âœ… Canonical Recursive Parser Rules

(strictly aligned to your catalogs)

â¸»

1ï¸âƒ£ UNIT HIERARCHY (non-negotiable)

TOKEN â†’ UNIT_WORD â†’ UNIT_COMPOUND â†’ UNIT_CLAUSE â†’ UNIT_SENTENCE

	â€¢	Bottom-up only
	â€¢	No token duplication across units
	â€¢	A higher unit owns only what is not owned by children

â¸»

2ï¸âƒ£ UNIT DEFINITIONS (exactly as your catalog)

ğŸ”¹ UNIT_WORD â€” ÙƒÙ„Ù…Ø©

A single lexical item.

Word types (must use catalog):
	â€¢	WORD_NOUN
	â€¢	WORD_VERB
	â€¢	WORD_PARTICLE
	â€¢	WORD_INTERJECTION

âœ… Examples
	â€¢	Ù†Ø­Ù† â†’ WORD_NOUN
	â€¢	Ù†Ù‚Øµ â†’ WORD_VERB
	â€¢	Ø£ÙˆØ­Ù‰ â†’ WORD_VERB
	â€¢	Ø¥Ù† â†’ WORD_PARTICLE

â¸»

ğŸ”¹ UNIT_COMPOUND â€” Ù…Ø±ÙƒØ¨

A grammatical grouping that is NOT a sentence.

Allowed compound types (only from your catalog):
	â€¢	COMP_IDAFI â†’ Ù…Ø¶Ø§Ù + Ù…Ø¶Ø§Ù Ø¥Ù„ÙŠÙ‡
	â€¢	COMP_WASFI â†’ Ù…ÙˆØµÙˆÙ + ØµÙØ©
	â€¢	COMP_JAR_MAJRUR â†’ Ø­Ø±Ù Ø¬Ø± + Ø§Ø³Ù…
	â€¢	COMP_ZARF â†’ Ø¸Ø±Ù + Ù…ØªØ¹Ù„Ù‘Ù‚
	â€¢	COMP_HARFI â†’ Ø­Ø±Ù + Ù…ØªØ¹Ù„Ù‘Ù‚

âŒ A compound can NEVER be promoted to UNIT_SENTENCE.

âœ… Examples
	â€¢	Ø¹Ù„ÙŠÙƒ â†’ COMP_JAR_MAJRUR
	â€¢	Ø£Ø­Ø³Ù† Ø§Ù„Ù‚ØµØµ â†’ COMP_IDAFI
	â€¢	Ù‚Ø¨Ù„Ù‡ â†’ COMP_IDAFI (Ù‚Ø¨Ù„ + Ù‡)

â¸»

ğŸ”¹ UNIT_CLAUSE â€” Ø¬Ù…Ù„Ø© ØµØºØ±Ù‰ / Ø´Ø¨Ù‡ Ø¬Ù…Ù„Ø©

A subordinate grammatical structure that may contain:
	â€¢	a verb
	â€¢	or a compound
	â€¢	or both

Clause grammar must be tagged using grammar_catalog.

Typical clauses:
	â€¢	ØµÙ„Ø© Ø§Ù„Ù…ÙˆØµÙˆÙ„
	â€¢	Ø­Ø§Ù„
	â€¢	ØªØ¹Ù„ÙŠÙ„
	â€¢	Ø´Ø±Ø·
	â€¢	Ø¸Ø±ÙÙŠÙ‘Ø©
	â€¢	Ù…Ù‚ÙˆÙ„ Ù‚ÙˆÙ„

âœ… Clause may be complete grammatically
âŒ Clause is not independent rhetorically

â¸»

ğŸ”¹ UNIT_SENTENCE â€” Ø¬Ù…Ù„Ø©

A complete thought unit.

Must be classified as:
	â€¢	GRAM_JUMLA_FIILIYYA
	â€¢	OR GRAM_JUMLA_ISMIYYA

â¸»

3ï¸âƒ£ SENTENCE PROMOTION RULES (CRITICAL)

âœ… Rule A â€” Verbal Sentence (Ø¬Ù…Ù„Ø© ÙØ¹Ù„ÙŠØ©)

IF
  a UNIT_CLAUSE contains WORD_VERB
AND
  (
    the verb is conjugated with an implicit subject
    OR an explicit ÙØ§Ø¹Ù„ exists
  )
THEN
  promote to UNIT_SENTENCE
  assign GRAM_JUMLA_FIILIYYA

âœ… Examples
	â€¢	Ø£ÙˆØ­ÙŠÙ†Ø§ â†’ sentence
	â€¢	Ø£ÙˆØ­ÙŠÙ†Ø§ Ø¥Ù„ÙŠÙƒ â†’ sentence
	â€¢	Ù†Ù‚Øµ Ø¹Ù„ÙŠÙƒ Ø£Ø­Ø³Ù† Ø§Ù„Ù‚ØµØµ â†’ sentence

â¸»

âœ… Rule B â€” Nominal Sentence (Ø¬Ù…Ù„Ø© Ø§Ø³Ù…ÙŠØ©)

IF
  clause contains:
    GRAM_MUBTADA
AND
  clause contains:
    GRAM_KHABAR or GRAM_KHABAR_JUMLA
THEN
  promote to UNIT_SENTENCE
  assign GRAM_JUMLA_ISMIYYA

âœ… Example
	â€¢	Ù†Ø­Ù† + (Ù†Ù‚Øµ Ø¹Ù„ÙŠÙƒ Ø£Ø­Ø³Ù† Ø§Ù„Ù‚ØµØµ)

â¸»

âŒ Rule C â€” Never a Sentence

The following must never be UNIT_SENTENCE:
	â€¢	UNIT_COMPOUND
	â€¢	WORD_PARTICLE alone
	â€¢	Connector without clause
	â€¢	Relative particle without ØµÙ„Ø©

Examples:
	â€¢	Ø¨Ù…Ø§ âŒ
	â€¢	Ø¹Ù„ÙŠÙƒ âŒ
	â€¢	Ø£Ø­Ø³Ù† Ø§Ù„Ù‚ØµØµ âŒ

â¸»

4ï¸âƒ£ COMPLEX SENTENCE RULE

A UNIT_SENTENCE is complex if it contains any of:
	â€¢	UNIT_CLAUSE children
	â€¢	GRAM_HAAL
	â€¢	GRAM_TAALIL
	â€¢	GRAM_ISTINAF
	â€¢	GRAM_INNA / GRAM_KANA
	â€¢	GRAM_SHART

"classification": {
  "simplicity": "complex",
  "grammar_ids": [
    "GRAM_JUMLA_FIILIYYA",
    "GRAM_TAALIL",
    "GRAM_HAAL"
  ]
}


â¸»

5ï¸âƒ£ CONNECTORS (control flow, not content)

Connectors must be tokens and assigned grammar IDs:

Token	Grammar ID
Ùˆ	GRAM_ATF / GRAM_ISTINAF
Ù	GRAM_ATF
Ø¥Ù†	GRAM_INNA
ÙƒØ§Ù†	GRAM_KANA

Rule:
	â€¢	Connector belongs to the parent sentence
	â€¢	The clause it introduces is a child UNIT_CLAUSE

â¸»

6ï¸âƒ£ RECURSIVE PARSING ALGORITHM (AI-SAFE)

Step 1 â€” Tokenize
	â€¢	Normalize text
	â€¢	Identify WORD_VERB / WORD_NOUN / WORD_PARTICLE

Step 2 â€” Build UNIT_COMPOUND
	â€¢	Detect jar-majrur, idafa, wasfi
	â€¢	Assign compound type

Step 3 â€” Build UNIT_CLAUSE (smallest first)
	â€¢	Detect minimal verbal cores (e.g. Ø£ÙˆØ­ÙŠÙ†Ø§)
	â€¢	Detect kana / inna frames
	â€¢	Attach compounds inside clause

Step 4 â€” Promote UNIT_SENTENCE
	â€¢	Apply promotion rules A / B
	â€¢	Assign grammar IDs

Step 5 â€” Assemble Root Sentence
	â€¢	Parent sentence owns only:
	â€¢	its own words
	â€¢	connectors
	â€¢	child clause references

â¸»

7ï¸âƒ£ HARD VALIDATION RULES (you already listed â€” correct)

âœ” all_sentence_ids_unique
âœ” each_sentence_has_single_root_clause
âœ” token_span_integrity_expected
âœ” subtypes_used_are_in_catalog

These are exactly right. Do not loosen them.

â¸»

ğŸ§  Final Architectural Truth

Grammar is structure, not text.
Text lives only at leaves.
Meaning emerges upward.

You now have a compiler-grade Arabic grammar system.

If you want next, I can:
	â€¢	âœ” apply this to 12:3 fully
	â€¢	âœ” generate canonical sentence JSON per node
	â€¢	âœ” define hash rules for universal IDs
	â€¢	âœ” help you design the AI prompt template

Just tell me the next step.